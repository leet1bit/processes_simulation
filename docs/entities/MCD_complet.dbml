Table PCB {
  var_adress hex // only in mcd not code
  pcb_id int pk
  process_name char(50)
  user_id char(20) // current user
  ppid int // pid du parent
  etat etat_enum // un des valeur aux etat-enum
  priorite int // 1 to 5
  /*
  normalement doit etre l adress du prochaine instruction 
  mais on va la stimuler avec un list des char,
  chaque char can either indicate to (use or dont use) ressource
  */
  instruction list(instruction) [ref: > instruction.instruction_id] // instruction that dont need ressource should be market as by example "pass"
  compteur_programe int // total instruction counte
  memoire_necessaire int // memoire necessaire en mbit
  
  burst_time float // (burst) temps necessaire pour l exec ; burst = compte_temps + temps_restant
  cpu_temps_used float // temps cpu consomme en ms "initialise a 0 increasing bu schedular"
  remaining_time float // temps restant en ms (initializer a burs decreasing jusqua 0)
  cpu_usage int // *importante* need cpu_logs in every instruct we log wich process did it and we sum process divide by total

  statistics process_statistics [ref : > process_statistics.var_name]

  pid_children list(int) // pointeur vers premier element du list des id des process chldren
  pid_siblings_next int // pointeur vers un next sibling block
  pid_siblings_previous int // pointeur vers previous sibling block
}

enum instruction_state {
  not_stated
  executing
  blocked
  completed 
}

enum instruction_type {
  io
}

Table instruction {
  instruction_id uint32_t // the id of instruction can exceed to millions of instructions
  process_id int // 

  time_remaining float

  type instruction_type
  state instruction_state
}


Table process_statistics {
  var_name hex // only here not code
  temps_arrive time // quand il etait ajouté au process_table
  temps_creation date_calendrier // quand la structure etait creer
  temps_fin time // when marked terminated

  temps_attente float // gap between temps arrive et temps exec
  tournround float // from temps arrive jusqua terminé
}

// pcb helper
enum etat_enum {
  "ready"
  "blocked"
  "execution"
  "terminated"
}

// should allocate all pcbs in memory then identify them
// store all the structures in a list store pointer to a variable ex: proc_table
Table process_table {
  var_adress hex // not in the code
  pid int // l id affecté au pcb
  pcb_id int [ref : > PCB.pcb_id] // l'id definie en pcb 
}


Table ready_queue_element {
  variable_adress hex // only in mcd not code
  pid int // process id
  next pointer // pointeur vers next element (depens on schedular algorithm)
  previous pointer // pointeur vers l element precedent (depens also on the schedular alogorithm)
}
// ready_queue shouln't modify the process_list but clone the process table elements after sorting or depens on the schedular
Table ready_queue {
  head pointeur [ref : > ready_queue_element.variable_adress ] // pointe vers ready_queue_element created by ready_queue function
  tail pointeur [ref: > ready_queue_element.variable_adress] // pointe vers ready_queue_element
  size int // n ready_queue_elements
}

Table ressources_element { // enum in dbml because mkatsupportech creation d LIST but list in code
  var_adress hex // only in mcd
  ressource_name char // name of the ressource "a" "b" anything
  disponibility bool // 1 dispo 0 no
}

Table ressources_list { // a simple list table just for dbml
  element resources_element [ref: > ressources_element.var_adress]
}

Table blocked_queue_elemnt {
  variable_adress hex // only here in mcd not code
  pid int
  ressource resources // ressource name
}

// blocked queue function should check every 1ms ressources
Table blocked_queue {
  var_adress hex // only here not code
  elemnts list [ref : > blocked_queue_elemnt.variable_adress] // blocked_queue simple list not structure, dbml dont support list 
}


enum algorithms {
  "rr" // round robin
  "srtf" // short remaining time first
  "ppp" // par priorite preemetive
  "fcfs" // first come first served
  "sjf" // short jo first
}

Table execution_queue {
  id int
  name char(10)

  current_instruction instruction [ref : > instruction.instruction_id]
  current_process pointer_pcb [ref : > PCB.var_adress]
  process_id int [ref : > process_table.pcb_id]
}

// sh
Table ordonnanceur { // which is schedular
  var_adress hex // only in mcd
  aligorithm algorithms // specified by user

  in_exec_proc_pcb pointerPCB [ref : > PCB.var_adress] // pointeur vers pcb du process en cours d execution

  quantum float // for rr
  start_time time 
  end_time time
  cpu_time_used float // en ms: end - start
  
  current_time float // en ms
  ready_queue ready_queue
  process_table process_table // list des processus


  is_runing bool
  is_paused bool

  statistics ordonnanceur_statistics [ref : > ordonnanceur_statistics.var_adress] // pointeur vers ordonnanceur_statistics
}

Table ordonnanceur_statistics {
  var_adress hex // only here not in structs
  cpu_total_temps_usage float // temps total pour tout processus cpu occupe
  cpu_temps_unoccuped float // temps total que le cpu n'etait pas utilise
  context_switch int // nombre total de changement de context (changement de processus a executer)
  total_temps_attente float // somme de temps attente de tout processus

  // when a process terminate
  total_turnround float // somme de temps turnround (temps termine - temps arrive)
  processus_termine_count int // les processus terminé
  troughtput float // process terminé / total time en ms
}

Table ressource_manager {
  var_adress hex // only in mcd
  ressources ressources_list [ref : > ressources_list.element]
  ressource_count int
} 

Table process_manager {
  var_adress hex // only in mcd
  process_table pointeur [ref: > process_table.var_adress] // pointe vers process table
  process_count int // nombre des process
  blocked_queue blocked_queue [ref : > blocked_queue.var_adress]
  ready_queue ready_queue [ref : > ready_queue.head]
}

Table simualtor {
  ressource_manager pointeurRessourcemanager [ref : > ressource_manager.var_adress ] // pointeur vers ressource manager
  process_manager  pointerProcess_manager [ref : > process_manager.var_adress] // pointeur vers process manager
  schedular ordonnanceur [ref : > ordonnanceur.var_adress] // depens on the choice of the user
  runing bool // state
}