Table PCB {
  pcb_id int pk
  process_name char(50)
  user_id char(20) // current user
  ppid int // pid du parent
  etat etat_enum // un des valeur aux etat-enum
  priorite int // 1 to 5
  /*
  normalement doit etre l adress du prochaine instruction 
  mais on va la stimuler avec un list des char,
  chaque char can either indicate to (use or dont use) ressource
  */
  instruction list(resources_element) // instruction that dont need ressource should be market as by example "pass"
  compteur_programe int // total instruction counte
  memoire_necessaire float // memoire necessaire en mbit
  
  burst_time float // (burst) temps necessaire pour l exec ; burst = compte_temps + temps_restant
  cpu_time_used float // temps cpu consomme en ms "initialise a 0 increasing bu schedular"
  remaining_time float // temps restant en ms (initializer a burs decreasing jusqua 0)
  cpu_usage int // *importante* need cpu_logs in every instruct we log wich process did it and we sum process divide by total

  statistics process_statistics [ref : > process_statistics.var_name]

  pid_children list(int) // pointeur vers premier element du list des id des process chldren
  pid_siblings_next int // pointeur vers un next sibling block
  pid_siblings_previous int // pointeur vers previous sibling block
}

Table process_statistics {
  var_name hex // only here not code
  temps_arrive time // quand il etait ajouté au process_table
  temps_creation time // quand la structure etait creer
  temps_execution time // time total needed en ms -> burst time
  temps_fin time // when marked terminated

  temps_attente float // gap between temps arrive et temps exec
  tournround float // from temps arrive jusqua terminé
}

// pcb helper
enum etat_enum {
  "ready"
  "blocked"
  "execution"
  "terminated"
}

// should allocate all pcbs in memory then identify them
// store all the structures in a list store pointer to a variable ex: proc_table
Table process_table {
  pid int // l id affecté au pcb
  pic_id int [ref : > PCB.pcb_id] // l'id definie en pcb 
}


Table ready_queue_element {
  variable_adress hex // only in mcd not code
  pid int // process id
  next pointer // pointeur vers next element (depens on schedular algorithm)
  previous pointer // pointeur vers l element precedent (depens also on the schedular alogorithm)
}
// ready_queue shouln't modify the process_list but clone the process table elements after sorting or depens on the schedular
Table ready_queue {
  head pointeur [ref : > ready_queue_element.variable_adress ] // pointe vers ready_queue_element created by ready_queue function
  tail pointeur [ref: > ready_queue_element.variable_adress] // pointe vers ready_queue_element
  size int // n ready_queue_elements
}

Table resources_element { // enum in dbml because mkatsupportech creation d LIST but list in code
  ressource_name char // name of the ressource "a" "b" anything
  disponibility bool // 1 dispo 0 no
}

Table ressources_list { // a simple list table just for dbml
  element resources_element
}

Table blocked_queue_elemnt {
  variable_adress hex // only here in mcd not code
  pid int
  ressource resources // ressource name
}

// blocked queue function should check every 1ms ressources
Table blocked_queue {
  elemnts list [ref : > blocked_queue_elemnt.variable_adress] // blocked_queue simple list not structure, dbml dont support list 
}


enum algorithms {
  "rr" // round robin
  "srtf" // short remaining time first
  "ppp" // par priorite preemetive
  "fcfs" // first come first served
  "sjf" // short jo first
}

// sh
Table ordonnanceur { // which is schedular
  aligorithm algorithms // specified by user
  ready_queue ready_queue [ref : > ready_queue.head]
  in_exec_proc_pcb PCB // pcb du process en cours d execution
  blocked_queue blocked_queue // [ref : > blocked_queue]

  quantum float // for rr
  start time 
  end time
  cpu_time_used float // en ms: end - start

  ressources ressources_list [ref : > ressources_list.element]
}






































