

// PCB* op_create_ready_queue(PROCESS_MANAGER* self, PCB* pcb, bool circular) {  // we dont pass the algo because it initialized before the schedular
    
//     if (pcb == NULL) {
//         fprintf(stderr, "ERROR ON: op_create_ready_queue failed has pcb is NULL\n");
//         exit(1);
//     }

//     // first pcb in the ready queue
//     PCB* ready_queue_head = (PCB*)malloc(sizeof(PCB));

//     if (ready_queue_head == NULL) {
//         fprintf(stderr, "ERROR ON: op_create_ready_queue , readu_queue_head allocation returned NULL\n");
//         exit(1);
//     }

//     // Perform a deep copy of the PCB
//     *ready_queue_head = *pcb;
//     ready_queue_head->pid_sibling_next = NULL; // Detach from the original list to avoid corruption

//     // Allocate new memory for statistics and copy the data
//     ready_queue_head->statistics = (PROCESS_STATISTICS*)malloc(sizeof(PROCESS_STATISTICS));
//     if (ready_queue_head->statistics == NULL) {
//         fprintf(stderr, "ERROR ON: op_create_ready_queue, ready_queue_head->statistics allocation returned NULL\n");
//         free(ready_queue_head);
//         exit(1);
//     }
//     if (pcb->statistics != NULL) {
//         *(ready_queue_head->statistics) = *(pcb->statistics);
//     } else {
//         // Handle case where original statistics is NULL, maybe just zero it out
//         memset(ready_queue_head->statistics, 0, sizeof(PROCESS_STATISTICS));
//     }

//     PCB* list_pcb_head_next = pcb->pid_sibling_next; // because we already have the first lement
//     PCB* ready_pcb_head = ready_queue_head;

//     // copy all nodes
//     while (list_pcb_head_next != NULL) {
//         // allocate a node
//         PCB* next_node = (PCB*)malloc(sizeof(PCB));
//         if (next_node == NULL) {
//             // if allocation failed
//             fprintf(stderr, "ERROR ON: op_create_ready_queue , next_node allocation returned NULL\n");
//             // free the chaine first
//             PCB* temp = ready_queue_head;
//             while (temp != NULL) {
//                 PCB* next = temp->pid_sibling_next;
//                 free(temp);
//                 temp = next;
//             }
//             exit(1);
//         }

//         // Perform a deep copy of the PCB
//         *next_node = *list_pcb_head_next;
//         // Allocate new memory for statistics and copy the data
//         next_node->statistics = (PROCESS_STATISTICS*)malloc(sizeof(PROCESS_STATISTICS));
//         if (next_node->statistics == NULL) {
//             fprintf(stderr, "ERROR ON: op_create_ready_queue, next_node->statistics allocation returned NULL\n");
//             // Proper cleanup needed here
//             exit(1);
//         }
//         if (list_pcb_head_next->statistics != NULL) {
//             *(next_node->statistics) = *(list_pcb_head_next->statistics);
//         } else {
//             memset(next_node->statistics, 0, sizeof(PROCESS_STATISTICS));
//         }


//         // chained it
//         ready_pcb_head->pid_sibling_next = next_node;

//         // move to next
//         ready_pcb_head = ready_pcb_head->pid_sibling_next;
//         list_pcb_head_next = list_pcb_head_next->pid_sibling_next;
//         }

//         if (circular == false) {
//             // make the last point to null
//             PCB* current = ready_queue_head; // for iteration
            
//             if (current != NULL) {
//                 while (current->pid_sibling_next != NULL) {
//                     current = current->pid_sibling_next;
//                 }
//                 current->pid_sibling_next = NULL;  // null in the end        
//             }
//         } else {
//             // make last node pointe to the head
//             if (ready_queue_head != NULL) {
//                 PCB* current = ready_queue_head; // for the iteration
                
//                 // find last
//                 while (current->pid_sibling_next != NULL && 
//                     current->pid_sibling_next != ready_queue_head) {
//                     current = current->pid_sibling_next;
//                 }
                
//                 // last will pointe to head for circular
//                 current->pid_sibling_next = ready_queue_head;
//             }
//         }

//     return ready_queue_head;
// }